---
title: 面试-手写代码篇
date: 2024-04-09T14:00:00Z
lang: zh
duration: 20min
---

---
## 手写代码

### 1.js数组去重

在JavaScript中，有多种方法可以实现数组去重。以下是其中的几种常见方法：

1. 使用 Set
Set 是 JavaScript 中一个内建的对象，它只允许存储唯一的值。利用这一特性，我们可以轻松实现数组去重。

``` javaScript
function uniqueArray(arr) {  
  return [...new Set(arr)];  
} 

const array = [1, 2, 3, 4, 4, 3, 2, 1];  
const unique = uniqueArray(array);  
console.log(unique); // 输出: [1, 2, 3, 4]

```

2. 使用 filter
你也可以使用数组的 filter 方法来实现去重。这个方法会遍历数组，并对每个元素执行一个测试函数，只有使测试函数返回 true 的元素才会被保留在新数组中。
``` javascript
function uniqueArray(arr) {  
  
  return arr.filter((item,index)=> {arr.indexOf(item)===index})
}  
  
const array = [1, 2, 3, 4, 4, 3, 2, 1];  
const unique = uniqueArray(array);  
console.log(unique); // 输出: [1, 2, 3, 4]
```
注意：这个方法在处理大数组时可能效率不高，因为它需要对每个元素都调用 indexOf 方法，而这个方法本身的时间复杂度就是 O(n)。

3. 使用 reduce
reduce 方法也可以用来实现数组去重。这个方法会遍历数组，并将每个元素归并成一个单一的结果。你可以利用这个结果来创建一个新数组，只包含唯一的元素。

``` javascript

let arrResult2 = arr5.reduce((pre, cur) => {
	if (!pre.includes(cur)) {
		pre.push(cur)
	}
	return pre
}, [])


function uniqueArray(arr) {  
  return arr.reduce((accumulator, current) => {  
    if (!accumulator.includes(current)) {  
      accumulator.push(current);  
    }  
    return accumulator;  
  }, []);  
}  

function uniqueArray(arr) {
  return arr.reduce((pre,cur)=> {
    if(!pre.includes(cur)){
      pre.push(cur)
    }
    return pre
  },[])
}
const array = [1, 2, 3, 4, 4, 3, 2, 1];  
const unique = uniqueArray(array);  
console.log(unique); // 输出: [1, 2, 3, 4]
```

4. 使用新特性（如 nullish coalescing 和可选链）
如果你在使用较新的JavaScript版本（ECMAScript 2020 或更高），你可以使用一些新特性来更简洁地实现数组去重。但这并不一定会提高性能，只是代码可能更简洁。
例如，结合 Set 和展开语法：

``` javascript
const array = [1, 2, 3, 4, 4, 3, 2, 1];  
const unique = [...new Set(array)];  
console.log(unique); // 输出: [1, 2, 3, 4]
```

以上就是几种常见的在JavaScript中实现数组去重的方法。你可以根据自己的需求和喜好来选择使用哪一种。


### 2.js将数字每千分位用逗号隔开

在JavaScript中，你可以使用toLocaleString方法将数字格式化为带有千分位逗号的字符串。这个方法会根据你所在地区的本地化设置来格式化数字。
以下是一个简单的例子：
``` javascript
let num = 1234567.89;  
let formattedNum = num.toLocaleString();  
console.log(formattedNum);  // 输出可能是 "1,234,567.89"
```
在这个例子中，toLocaleString方法会自动在数字的千分位处添加逗号。注意，输出的格式可能会因你的本地化设置而异。
如果你想要确保输出的格式不受本地化设置的影响，你可以为toLocaleString方法提供一个选项对象，明确指定你想要的语言环境（locale）。例如，如果你想要使用美国英语的格式（即使用逗号作为千分位分隔符，点作为小数点），你可以这样做：
``` javascript 
let num = 1234567.89;  
let formattedNum = num.toLocaleString('en-US');  
console.log(formattedNum);  // 输出 "1,234,567.89"
```
在这个例子中，无论你的本地化设置是什么，输出的格式都会是美国英语的格式。

### 3.手写防抖节流
在JavaScript中，防抖（debounce）和节流（throttle）是两种常用的优化高频触发事件的策略。它们通常用于窗口大小调整、滚动、输入等场景，以减少事件处理函数的执行频率，提高性能。
- 防抖（Debounce）
防抖是指事件被触发后，n秒内函数只能执行一次，如果在这n秒内又被触发，则重新计算执行时间。
下面是一个简单的防抖函数实现：

``` javascript 
function debounce(func, wait) {  
  let timeout;  
  return function() {  
    const context = this;  
    const args = arguments;  
    clearTimeout(timeout);  
    timeout = setTimeout(function() {  
      func.apply(context, args);  
    }, wait);  
  };  
}  
  
// 使用示例  
const myEfficientFn = debounce(function() {  
  // 需要防抖执行的函数  
}, 250);  
  
window.addEventListener('resize', myEfficientFn);
```

- 节流（Throttle）
节流是指连续触发事件，但在n秒内只执行一次函数。
下面是一个简单的节流函数实现：
``` javascript 
function throttle(func, limit) {  
  let inThrottle;  
  return function() {  
    const context = this;  
    const args = arguments;  
    if (!inThrottle) {  
      func.apply(context, args);  
      inThrottle = true;  
      setTimeout(function() {  
        return inThrottle = false;  
      }, limit);  
    }  
  };  
}  
  
// 使用示例  
const myEfficientFn = throttle(function() {  
  // 需要节流执行的函数  
}, 250);  
  
window.addEventListener('scroll', myEfficientFn);
```

- 注意事项
****
- 这两个函数都返回一个新的函数，这个新函数会包装传入的原始函数，并根据防抖或节流的逻辑来调用它。
- 防抖和节流的区别在于，防抖是在事件触发后等待一段时间再执行，而节流是确保事件触发后的一段时间内只执行一次。
- 这两个函数都可以接受任意数量的参数，并将它们传递给原始函数。
- 在实际应用中，你可能需要根据你的需求对这两个函数进行扩展或调整。

